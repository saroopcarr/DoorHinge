// prisma/schema.prisma
// This file defines our database models (tables) and relationships
// Prisma generates TypeScript types from this - no need for manual type definitions!

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User: Core identity model - stores credentials
model User {
  id                String              @id @default(uuid())
  email             String              @unique
  phone             String              @unique
  passwordHash      String
  role              Role                @default(SEEKER)
  isVerified        Boolean             @default(false)
  isPhoneVerified   Boolean             @default(false)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  // Relations to other tables
  ownerProfile      OwnerProfile?
  seekerProfile     SeekerProfile?
  sessions          Session[]
  likedProperties   Like[]
  matchesAsOwner    Match[]             @relation("OwnerMatches")
  matchesAsSeeker   Match[]             @relation("SeekerMatches")
  sentMessages      Message[]
  notifications     Notification[]

  @@index([email])
  @@index([phone])
  @@index([role])
}

// OwnerProfile: Extended data for Property owners
model OwnerProfile {
  id                  String              @id @default(uuid())
  userId              String              @unique
  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  businessName        String?
  bio                 String?
  verificationStatus  VerificationStatus  @default(PENDING)
  verificationProof   String?
  isProfileComplete   Boolean             @default(false)
  
  properties          Property[]
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  @@index([userId])
  @@index([verificationStatus])
}

// SeekerProfile: Extended data for Property seekers
model SeekerProfile {
  id                String              @id @default(uuid())
  userId            String              @unique
  user              User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  firstName         String
  lastName          String
  age               Int
  gender            Gender
  employmentStatus  EmploymentStatus
  rentPurpose       RentPurpose
  
  // For bachelors
  allowedGenders    Gender[]            @default([])
  occupantCount     Int?
  
  // For family
  familySize        Int?
  
  maxBudget         Int                 // in rupees/local currency
  preferredAreas    String[]            @default([])
  moveInDate        DateTime
  bio               String?
  isProfileComplete Boolean             @default(false)
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@index([userId])
  @@index([rentPurpose])
  @@index([maxBudget])
}

// Property: Rental listings created by Owners
model Property {
  id                String              @id @default(uuid())
  ownerId           String
  owner             OwnerProfile        @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  
  title             String
  description       String
  area              String              // Area name, not exact location (privacy)
  latitude          Float?              // Optional: for map features
  longitude         Float?
  
  bedrooms          BedroomCount
  furnishedStatus   FurnishedStatus
  
  rentAmount        Int                 // Monthly rent
  maintenanceAmount Int                 // Monthly maintenance
  deposit           Int                 // Security deposit
  
  amenities         String[]            @default([])
  houseRules        String[]            @default([])
  
  availabilityDate  DateTime
  isActive          Boolean             @default(true)
  
  photos            Media[]
  likes             Like[]
  matches           Match[]
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@index([ownerId])
  @@index([area])
  @@index([isActive])
  @@index([availabilityDate])
}

// Media: Photos and videos for properties
model Media {
  id                String              @id @default(uuid())
  propertyId        String
  property          Property            @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  url               String
  cloudinaryId      String?             // For Cloudinary deletions
  type              MediaType
  order             Int                 @default(0)
  
  createdAt         DateTime            @default(now())

  @@index([propertyId])
}

// Like: When a Seeker "likes" a property
model Like {
  id                String              @id @default(uuid())
  userId            String
  propertyId        String
  
  user              User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  property          Property            @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  createdAt         DateTime            @default(now())

  @@unique([userId, propertyId])
  @@index([userId])
  @@index([propertyId])
}

// Match: When Owner likes back (mutual like)
model Match {
  id                String              @id @default(uuid())
  propertyId        String
  ownerId           String
  seekerId          String
  
  property          Property            @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  owner             User                @relation("OwnerMatches", fields: [ownerId], references: [id], onDelete: Cascade)
  seeker            User                @relation("SeekerMatches", fields: [seekerId], references: [id], onDelete: Cascade)
  
  status            MatchStatus         @default(ACTIVE)
  messages          Message[]
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@unique([propertyId, seekerId])
  @@index([ownerId])
  @@index([seekerId])
  @@index([status])
}

// Message: Real-time chat stored in DB
model Message {
  id                String              @id @default(uuid())
  matchId           String
  senderId          String
  
  match             Match               @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender            User                @relation(fields: [senderId], references: [id], onDelete: Cascade)
  
  content           String
  attachmentUrl     String?
  read              Boolean             @default(false)
  readAt            DateTime?
  
  createdAt         DateTime            @default(now())

  @@index([matchId])
  @@index([senderId])
  @@index([read])
}

// Session: JWT refresh tokens
model Session {
  id                String              @id @default(uuid())
  userId            String
  user              User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  refreshToken      String              @unique
  expiresAt         DateTime
  userAgent         String?
  ipAddress         String?
  
  createdAt         DateTime            @default(now())

  @@index([userId])
  @@index([expiresAt])
}

// Notification: For matches and messages
model Notification {
  id                String              @id @default(uuid())
  userId            String
  user              User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type              NotificationType
  message           String
  relatedId         String?             // Match ID or Message ID
  isRead            Boolean             @default(false)
  
  createdAt         DateTime            @default(now())

  @@index([userId])
  @@index([isRead])
}

// ===== ENUMS (Type definitions for database fields) =====

enum Role {
  OWNER
  SEEKER
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum EmploymentStatus {
  STUDENT
  EMPLOYED
  SELF_EMPLOYED
  UNEMPLOYED
  RETIRED
}

enum RentPurpose {
  BACHELORS
  FAMILY
}

enum BedroomCount {
  STUDIO
  ONE
  TWO
  THREE
  FOUR
  FOUR_PLUS
}

enum FurnishedStatus {
  FURNISHED
  SEMI_FURNISHED
  UNFURNISHED
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum MediaType {
  IMAGE
  VIDEO
}

enum MatchStatus {
  ACTIVE
  ARCHIVED
  BLOCKED
}

enum NotificationType {
  NEW_LIKE
  NEW_MATCH
  NEW_MESSAGE
  PROFILE_VERIFIED
}
